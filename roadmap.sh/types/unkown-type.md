
---

# üìò TypeScript `unknown` ‚Äì Complete Notes

---

## üîπ What is `unknown`?

- `unknown` is a **TypeScript-exclusive** type introduced in v3.0.
- It represents a value **that could be anything**, just like `any`, but is **safer**.
- It is the **type-safe counterpart to `any`**.

```ts
let value: unknown;
value = 5;       // ‚úÖ okay
value = "hello"; // ‚úÖ okay
value = true;    // ‚úÖ okay
```

---

## üîπ Why use `unknown` over `any`?

| Feature       | `any`                        | `unknown`                            |
|---------------|-------------------------------|--------------------------------------|
| Assign anything? | ‚úÖ Yes                      | ‚úÖ Yes                                |
| Use anything on the value? | ‚úÖ Yes (unsafe)         | ‚ùå No (must narrow the type first)   |
| Safe?         | ‚ùå No ‚Äì skips type checking   | ‚úÖ Yes ‚Äì forces type checking         |

---

## üîπ Rules and Restrictions of `unknown`

### 1. ‚úÖ **Can assign any type to `unknown`**
```ts
let x: unknown;

x = 10;
x = "string";
x = { a: 1 };
x = [1, 2, 3];
x = null;
x = undefined;
```

---

### 2. ‚ùå **Cannot use properties/methods on an `unknown` variable directly**
```ts
let value: unknown;

// value.trim();       ‚ùå Error
// value.toFixed(2);   ‚ùå Error

if (typeof value === "string") {
  console.log(value.trim());  // ‚úÖ OK ‚Äì type narrowed
}
```

---

### 3. ‚ùå **Cannot assign `unknown` directly to other specific types (without checks or assertion)**

```ts
let value: unknown;
let str: string;

// str = value;           ‚ùå Error: Type 'unknown' is not assignable to type 'string'

if (typeof value === "string") {
  str = value;           // ‚úÖ OK
}
```

---

## üîπ Type Narrowing with `unknown`

Before using an `unknown` value, you **must narrow** its type using:

### ‚úÖ `typeof`
```ts
if (typeof value === "number") {
  console.log(value.toFixed(2));
}
```

### ‚úÖ `instanceof`
```ts
if (value instanceof Date) {
  console.log(value.getFullYear());
}
```

### ‚úÖ `Array.isArray()`
```ts
if (Array.isArray(value)) {
  console.log(value.length);
}
```

### ‚úÖ Type assertion
```ts
console.log((value as string).toUpperCase());
```

---

## üîπ `unknown` vs Other Types (Comparison Table)

| Expression              | Result    |
|-------------------------|-----------|
| `unknown` ‚äá all types   | ‚úÖ Yes     |
| All types ‚äÜ `unknown`   | ‚ùå No      |
| `unknown` assign to any specific type? | ‚ùå No (without narrowing/assertion) |
| Assign to `any` or `unknown`? | ‚úÖ Yes |

---

## üîπ Function Return Type as `unknown`

```ts
function parseJson(json: string): unknown {
  return JSON.parse(json);
}

const data = parseJson('{"name":"John"}');

// data.name; ‚ùå Error ‚Äî unknown type, must narrow or assert
```

---

## üîπ `unknown` in Union and Intersection Types

### In **unions**, `unknown` absorbs all other types:

```ts
type A = unknown | string;  // same as unknown
```

### In **intersections**, `unknown` acts as identity:

```ts
type B = unknown & string;  // same as string
```

---

## üîπ Use Cases of `unknown`

### 1. Safer `any` in public APIs
```ts
function handleInput(input: unknown) {
  if (typeof input === "string") {
    console.log(input.toUpperCase());
  }
}
```

### 2. Deserializing data (like from JSON)
```ts
function parseData(json: string): unknown {
  return JSON.parse(json);
}
```

### 3. Handling data from untyped sources
```ts
let userInput: unknown = getExternalData(); // e.g., from `any`, 3rd-party lib
```

---

## üîπ Other Behavior Highlights

### 1. `unknown` is not comparable directly
```ts
let x: unknown;
let y: unknown;

// console.log(x === y); ‚úÖ Works at runtime (JS allows it), but TS may not infer anything useful
```

### 2. Type guards make `unknown` powerful
```ts
function isString(value: unknown): value is string {
  return typeof value === "string";
}
```

---

## ‚úÖ Best Practices

- Use `unknown` when you're working with **dynamic data** (e.g., APIs, user input).
- **Always narrow the type** before using the value.
- Prefer `unknown` over `any` for safety in large codebases.
- Avoid using `unknown` for internal variables unless strictly needed.

---

---

### ‚úÖ **1. Intersection Types with `unknown`**

```ts
type T00 = unknown & null; // null
type T01 = unknown & undefined; // undefined
type T02 = unknown & null & undefined; // null & undefined (which becomes never)
type T03 = unknown & string; // string
type T04 = unknown & string[]; // string[]
type T05 = unknown & unknown; // unknown
type T06 = unknown & any; // any
```

**Explanation**:
- In intersection types (`&`), `unknown` behaves like a **neutral type**.
- The result is usually the **other type**, unless the types are mutually exclusive.

| Expression | Result        | Why? |
|------------|---------------|------|
| `unknown & null` | `null` | `null` is more specific than `unknown`. |
| `unknown & undefined` | `undefined` | Same reason. |
| `unknown & null & undefined` | `never` | Nothing can be both `null` and `undefined` at the same time. |
| `unknown & string` | `string` | It keeps the specific type. |
| `unknown & any` | `any` | `any` wins over everything. |
| `unknown & unknown` | `unknown` | Same type. |

---

### ‚úÖ **2. Union Types with `unknown`**

```ts
type T10 = unknown | null; // unknown
type T11 = unknown | undefined; // unknown
type T12 = unknown | null | undefined; // unknown
type T13 = unknown | string; // unknown
type T14 = unknown | string[]; // unknown
type T15 = unknown | unknown; // unknown
type T16 = unknown | any; // any
```

**Explanation**:
- In unions (`|`), `unknown` is **absorbing**‚Äîit hides all other types.
- Except for `any`, which always wins.

---

### ‚úÖ **3. Generics and `unknown`**

```ts
type T20<T> = T & {}; // T
type T21<T> = T | {}; // T | {}
type T22<T> = T & unknown; // T
type T23<T> = T | unknown; // unknown
```

**Explanation**:
- `T & {}` just removes `null` and `undefined`, but keeps structure.
- `T & unknown` is always just `T` (neutral type in intersections).
- `T | unknown` is always `unknown` (absorbs anything).

---

### ‚úÖ **4. Conditional Types with `unknown`**

```ts
type T30<T> = unknown extends T ? true : false; // Deferred
type T31<T> = T extends unknown ? true : false; // Deferred
type T32<T> = never extends T ? true : false; // true
type T33<T> = T extends never ? true : false; // Deferred
```

**Explanation**:
- Conditional types involving generic `T` are **deferred** (evaluated later).
- `never extends T` is always `true`, because `never` is a subtype of all types.

---

### ‚úÖ **5. `keyof unknown`**

```ts
type T40 = keyof any; // string | number | symbol
type T41 = keyof unknown; // never
```

**Explanation**:
- You can get keys from `any` (like object keys), but not from `unknown` because its structure is... unknown!

---

### ‚úÖ **6. Only Equality Operators Allowed**

```ts
function f10(x: unknown) {
  x == 5;        // ‚úÖ OK
  x !== 10;      // ‚úÖ OK
  x >= 0;        // ‚ùå Error
  x + 1;         // ‚ùå Error
  x * 2;         // ‚ùå Error
  -x;            // ‚ùå Error
  +x;            // ‚ùå Error
}
```

**Explanation**:
- With `unknown`, you can compare for equality (`==`, `===`) but **cannot do arithmetic** or logical operations unless the type is narrowed.

---

### ‚úÖ **7. No Property Access or Function Call**

```ts
function f11(x: unknown) {
  x.foo;     // ‚ùå Error
  x[5];      // ‚ùå Error
  x();       // ‚ùå Error
  new x();   // ‚ùå Error
}
```

**Explanation**:
- You cannot do anything with `x` unless you **know what it is**. `unknown` blocks access to properties, methods, or function calls.

---

### ‚úÖ **8. Type Narrowing with `typeof`, `instanceof`, or Custom Predicate**

```ts
declare function isFunction(x: unknown): x is Function;

function f20(x: unknown) {
  if (typeof x === "string" || typeof x === "number") {
    x; // ‚úÖ string | number
  }
  if (x instanceof Error) {
    x; // ‚úÖ Error
  }
  if (isFunction(x)) {
    x; // ‚úÖ Function
  }
}
```

**Explanation**:
- TypeScript allows access only **after narrowing** the type via `typeof`, `instanceof`, or user-defined type guards.

---

### ‚úÖ **9. Mapped Types over `unknown`**

```ts
type T50<T> = { [P in keyof T]: number };
type T51 = T50<any>;     // { [x: string]: number }
type T52 = T50<unknown>; // {}
```

**Explanation**:
- You can‚Äôt map over the properties of `unknown` (because it has none), so it results in an **empty object** type.

---

### ‚úÖ **10. Assigning to `unknown` is always allowed**

```ts
function f21<T>(pAny: any, pNever: never, pT: T) {
  let x: unknown;
  x = 123;
  x = "hello";
  x = [1, 2, 3];
  x = new Error();
  x = x;
  x = pAny;
  x = pNever;
  x = pT;
}
```

**Explanation**:
- You can assign **anything** to `unknown`.

---

### ‚úÖ **11. But `unknown` can only be assigned to `any` or `unknown`**

```ts
function f22(x: unknown) {
  let v1: any = x;        // ‚úÖ
  let v2: unknown = x;    // ‚úÖ
  let v3: object = x;     // ‚ùå
  let v4: string = x;     // ‚ùå
  let v5: string[] = x;   // ‚ùå
  let v6: {} = x;         // ‚ùå
  let v7: {} | null | undefined = x; // ‚ùå
}
```

**Explanation**:
- You can't assign `unknown` to more specific types unless you narrow or assert.

---

### ‚úÖ **12. Generic `T extends unknown` isn't enough**

```ts
function f23<T extends unknown>(x: T) {
  let y: object = x; // ‚ùå Error
}
```

**Explanation**:
- Even if `T` is a subtype of `unknown`, TypeScript doesn't know if it's an object unless you narrow it.

---

### ‚úÖ **13. Index signature with `unknown` values**

```ts
function f24(x: { [x: string]: unknown }) {
  x = {};            // ‚úÖ
  x = { a: 5 };       // ‚úÖ
  x = [1, 2, 3];      // ‚úÖ (arrays are objects)
  x = 123;            // ‚ùå
}
```

**Explanation**:
- Any object-like value is fine. Primitives like `123` are not allowed.

---

### ‚úÖ **14. Local variables of type `unknown` are always considered initialized**

```ts
function f25() {
  let x: unknown;
  let y = x; // ‚úÖ
}
```

**Explanation**:
- You don‚Äôt need to initialize `x` before using it ‚Äî it's considered initialized by TS.

---

### ‚úÖ **15. Spreading `unknown` makes the result `unknown`**

```ts
function f26(x: {}, y: unknown, z: any) {
  let o1 = { a: 42, ...x };             // ‚úÖ { a: number }
  let o2 = { a: 42, ...x, ...y };       // ‚ùå becomes unknown
  let o3 = { a: 42, ...x, ...y, ...z }; // ‚ùå becomes any
}
```

**Explanation**:
- When you spread an `unknown`, the type of the result becomes `unknown`‚Äîbecause TS doesn‚Äôt know what‚Äôs inside `y`.

---

### ‚úÖ **16. Function with `unknown` return type doesn‚Äôt need `return`**

```ts
function f27(): unknown {}
```

**Explanation**:
- Weird but allowed: Since the function ‚Äúmight‚Äù return anything (or nothing), it's legal to omit `return`.

---

### ‚úÖ **17. Rest object from `unknown` is not allowed**

```ts
function f28(x: unknown) {
  let { ...a } = x; // ‚ùå Error
}
```

**Explanation**:
- You can't destructure from `unknown`. The structure must be known first.

---

### ‚úÖ **18. Class properties of type `unknown` don't need initialization**

```ts
class C1 {
  a: string; // ‚ùå Error: must initialize
  b: unknown; // ‚úÖ OK
  c: any;     // ‚úÖ OK
}
```

**Explanation**:
- `unknown` is treated like `any`: TS assumes you‚Äôll initialize it later (no strict check).

---
